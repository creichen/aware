#! /usr/bin/env python3
#
# This file is Copyright (C) 2015 Christoph Reichenbach
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
#   Free Software Foundation, Inc.
#   59 Temple Place, Suite 330
#   Boston, MA  02111-1307
#   USA
#
# The author can be reached as "creichen" at the usual gmail server.


from __future__ import print_function
import configparser
import argparse
import cairo
import fcntl
import fileinput
import os
import os.path
import signal
import subprocess
import sys
import threading
import time
import traceback

def create_exclusive(filename):
    try:
        fd = os.open(filename, os.O_CREAT | os.O_EXCL | os.O_RDWR)
    except FileExistsError:
        return None
    return os.fdopen(fd, 'w')

def read_exclusive(filename):
    fd = os.open(filename, os.O_RDONLY | os.O_EXCL)
    return os.fdopen(fd, 'r')

################################################################################
# Basic information and utilities
################################################################################

VERSION = '0.4.0'
CONFIG_FILE = os.path.expanduser('~/.aware')
CONTROL_CHAR = '+'	# as in +text, +img, ...
ALLOCATION_TRIES = 10	# number of times we back off on trying to server lock before aborting

# Primitive logging interface
# When running in daemon mode, we currently discard all output.

log_output = sys.stderr

def log(*args):
    '''Writes all arguments to the log output stream.'''
    print(*args, file=log_output)


def parse_color(colname, default = 'white'):
    '''Parses the specified colour.  Prints an error message and backs up to a default if needed.'''
    colname.strip()
    if len(colname) > 2 and colname[0] == colname[-1] and colname[0] in '\'\"':
        colname = colname[1:len(colname) - 1]
    if len(colname) <= 9:
        def digit(d):
            try:
                return int(d, 16)
            except ValueError:
                None

        def cv(n):

            if len(n) == 2:
                maxv = 255.0
                v = (n[0] << 4) | n[1]
            else:
                maxv = 15.0
                v = n[0]
            return v / maxv

        def cvec(v, steplen):
            result = []
            while len(v):
                current = v[:steplen]
                v = v[steplen:]
                result.append(cv(current))
            if len(result) == 3:
                result.append(1.0)
            return result

        colname_stripped = colname[1:] if colname.startswith('#') else colname
        cn = [digit(d) for d in colname_stripped]
        if None not in cn and len(cn) in [3, 4, 6, 8]:
            # all valid digits
            return GUI.Gdk.RGBA(*(cvec(cn, 1 if len(cn) <= 4 else 2)))
    try:
        return GUI.Gdk.RGBA.from_color(GUI.Gdk.color_parse(colname))
    except Exception:
        log('Unknown color "%s"' % colname)
        return GUI.Gdk.RGBA.from_color(GUI.Gdk.color_parse(default))


################################################################################
# Confiugration
################################################################################

class Config(object):
    '''Configuration management class.'''

    def __init__(self):
        '''Initialise config data.  Instantiate once, and the class static fields will be configured.'''
        section = 'X'
        defaults = {}
        for d in Config.__dict__:
            if not d.startswith('_'):
                v = Config.__dict__[d]
                if type(v) != str:
                    v = str(v)
                defaults[d] = v
        config = configparser.ConfigParser(defaults)
        conf = {}
        try:
            f = open(CONFIG_FILE, 'r')
            config.read_file(['[%s]\n' % section] + list(f))
            conf = config.items(section)
        except IOError:
            pass
        for (k, v) in conf:
            if k not in Config.__dict__:
                log('Unknown option "%s"' % k)
                continue
            ov = Config.__dict__[k]
            try:
                if type(ov) is int:
                    v = int(v)
                elif type(ov) is float:
                    v = float(v)
                setattr(Config, k, v)
            except Exception as e:
                log(e.message)
                log('Expected %s for option %s but got "%s"' % (type(ov).__name__, k, v))

    pipe_file_name = os.path.expanduser('~/.aware-pipe')
    pid_file_name = os.path.expanduser('~/.aware-pid')
    update_safety_delay = 1.5   # amount of seconds after an update during which we reject SHUTDOWN message
    font = 'Sans Serif 8'
    bar_color = 'gray'
    default_fg_color = 'white'
    default_bg_color = 'black'
    column_separator_width = 5
    line_separator_width = 0
    max_width = 768
    max_height = 256


################################################################################
# Fonts
################################################################################

class Font(object):
    DEFAULT_SIZE = 8.0

    def __init__(self, name, size=None):
        self.name = name
        self.size = size
        if size is None:
            self.parse(name)

    def set(self, cr):
        cr.select_font_face(self.name, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        cr.set_font_size(self.size)

    def parse(self, string):
        if len(string) > 2 and string[0] == "'" and string[-1] == "'":
            string = string[1:-1]
        sections = string.split()
        size = Font.DEFAULT_SIZE
        if len(sections):
            try:
                size = float(sections[-1])
                sections = sections
                sections.pop()
            except ValueError:
                pass
        self.name = ' '.join(sections)
        self.size = size

    def full_name(self):
        return self.name + ' ' + str(self.size)


################################################################################
# Display objects for visualising strings, images etc.
################################################################################

class DObject(object):
    '''Represents an entity-to-visualise.'''

    def __init__(self):
        self.id = None # unique ID, permits overriding
        self.window = None

    def get_size(self):
        '''return (width, upper_height, lower_height)
        where upper_height is height to baseline and lower_height is height below'''
        pass

    def draw_to(self, cr, x, y):
        '''Draw yourself to the given context and coordinates'''
        self.draw(cr, x, y + self.get_baseline())

    def draw(self, cr, x, y):
        '''Draw yourself to the given context and coordinates (y refers to the baseline position)'''
        pass

    def set_window(self, window):
        '''Set the window to draw this widget to'''
        pass

    def get_width(self):
        return self.get_size()[0]

    def get_height(self):
        size = self.get_size()
        return size[1] + size[2]

    def get_baseline(self):
        return self.get_size()[1]

    def configure(self, key, value):
        '''Configure object to set key = value; return True if spec is appropriate'''
        if key == 'id':
            self.id = value
            return True
        return False

    def stop(self):
        '''Stops any background tasks that the DObject is executing'''
        pass

    def contained_elements(self):
        '''Retrieves all inner elements (for containers)'''
        return []

    def configure_end(self):
        '''Final sanity checks after all config is set'''
        return True


class DImage(DObject):
    '''A graphical image file (png, jpeg, ...) to display (+img)'''

    def __init__(self, image, width=None, height=None):
        DObject.__init__(self)
        image = image.strip()
        try:
            if image.endswith('.png'):
                self.source_pixbuf = cairo.ImageSurface.create_from_png(os.path.expanduser(image))
            else:
                raise('GTK/Cairo dropped support for non-png graphics.  Cannot load "%s".' % image)
            # GUI.GdkPixbuf.Pixbuf.new_from_file(os.path.expanduser(image))
        except Exception as e:
            log(e.message)
            log('Failed to load image "%s"' % image)
            raise e

        self.background_color = None
        self.width = self.source_pixbuf.get_width()
        self.height = self.source_pixbuf.get_height()
        self.force_width = None
        self.force_height = None
        self.max_width = Config.max_width
        self.max_height = Config.max_height
        self.pixbuf = None
        self.configure_end() # scale if needed

    def change_size(self):
        '''Recompute size and scale, if needed'''
        def fix(x, default):
            if x is None:
                return default
            elif x < 1:
                return 1
            else:
                return int(x)

        self.width = fix(self.width, self.source_pixbuf.get_width())
        self.height = fix(self.height, self.source_pixbuf.get_height())

        self.pixbuf = self.source_pixbuf

        if self.pixbuf is not None and self.pixbuf.get_width() == self.width and self.pixbuf.get_height() == self.height:
            return

        self.pixbuf = cairo.ImageSurface(self.source_pixbuf.get_format(), self.width, self.height)

        cr = cairo.Context(self.pixbuf)
        cr.rectangle(0, 0, self.width, self.height)
        cr.set_source_surface(self.source_pixbuf, 0, 0)
        cr.set_operator(cairo.OPERATOR_OVER)
        cr.scale((self.width * 1.0) / self.source_pixbuf.get_width(),
                   (self.height * 1.0) / self.source_pixbuf.get_height())
        cr.paint()

    def get_size(self):
        return (self.width, self.height, 0)

    def draw(self, cr, x, y):
        y -= self.get_baseline()

        cr.save()
        # draw background, if requested
        if self.background_color is not None:
            cr.rectangle(x, y,
                         self.width, self.height)
            cr.set_operator(cairo.OPERATOR_SOURCE)
            cr.set_source_rgba(*self.background_color)
            cr.fill()

        # cr.rectangle(x, y,
        #              self.width, self.height)
        cr.set_source_surface(self.pixbuf, x, y)
        cr.set_operator(cairo.OPERATOR_OVER)
        cr.paint();
        cr.restore();

    def configure(self, key, value):
        if key == 'width':
            self.force_width = int(value)
        elif key == 'height':
            self.force_height = int(value)
        elif key == 'maxwidth':
            self.max_width = int(value)
        elif key == 'maxheight':
            self.max_height = int(value)
        elif key == 'background':
            self.background_color = parse_color(value, 'black')
        else:
            return DObject.configure(self, key, value)
        return True

    def configure_end(self):
        downscale = None

        if self.force_width is not None:
            self.width = self.force_width
        elif self.width > self.max_width:
            downscale = float(self.max_width) / float(self.width)

        if self.force_height is not None:
            self.height = self.force_height
        elif self.height > self.max_height:
            d = float(self.max_height) / float(self.height)
            if downscale is None:
                downscale = d
            else:
                downscale = min(d, downscale)

        if downscale is not None:
            self.width = int(self.source_pixbuf.get_width() * downscale)
            self.height = int(self.source_pixbuf.get_height() * downscale)

        self.change_size()
        return True


class DText(DObject):
    '''Character string to display (+text)'''

    def __init__(self, text, color=None):
        DObject.__init__(self)
        self.text = text
        self.font = Font(Config.font)
        if color is None:
            color = Config.default_fg_color
        self.color = parse_color(color)

    def set_window(self, window):
        self.layout = window.create_pango_layout(self.text)
        self.layout.set_font_description(GUI.Pango.FontDescription(self.font.full_name()))

    def get_size(self):
        bo = int(self.layout.get_iter().get_baseline() / GUI.Pango.SCALE)
        width = int(self.layout.get_size()[0] / GUI.Pango.SCALE)
        height = int(self.layout.get_size()[1] / GUI.Pango.SCALE)
        return (width, bo, height - bo)

    def configure(self, key, value):
        if key == 'font':
            self.font = Font(value)
        elif key in ['color', 'colour']:
            self.color = parse_color(value)
            if self.color is None:
                return False
        else:
            return DObject.configure(self, key, value)
        return True

    def configure_end(self):
        self.text = self.text.strip()
        return True

    def draw(self, cr, x, y):
        self.font.set(cr)
        cr.set_source_rgba(*self.color)
        cr.move_to(x, y - self.get_baseline())
        GUI.PangoCairo.show_layout(cr, self.layout)

    def __str__(self):
        return 'DText(%s)' % self.text


class DContainer(DObject):
    '''Abstract container class'''

    def __init__(self, elements=None):
        DObject.__init__(self)
        if elements is None:
            elements = []
        self.id_map = {}
        self.elements = elements

    def update_element(self, index, element):
        if self.elements[index].id == element.id:
            self.elements[index].stop()
            self.elements[index] = element # and discard old element
        else:
            self.elements[index].append(element) # indirectly recurse into update_element handler for this dline

    def register(self, index, dline):
        # for contained dlines: register ids
        for n in dline.contained_elements():
            if n.id is not None:
                #print(type(self), ': registering id', n.id)
                self.id_map[n.id] = index
            self.register(index, n)

    def append(self, element):
        if self.window is not None:
            element.set_window(self.window)
        if element.id != None:
            if element.id in self.id_map:
                index = self.id_map[element.id]
                self.update_element(index, element)
                self.register(index, element)
                return
            else:
                self.id_map[element.id] = len(self.elements)
        self.elements.append(element)
        self.register(len(self.elements) - 1, element)

    def set_window(self, window):
        self.window = window
        for l in self.elements:
            l.set_window(window)

    def contained_elements(self):
        return self.elements
        return result


class DScript(DContainer):
    '''Script container (+script).  Contains a single element that may update itself.'''

    implicit_ids = 0	# used to assign unique IDs to contained scripts

    def __init__(self, script):
        DContainer.__init__(self)
        self.implicit_id = ' ' + str(DScript.implicit_ids)
        DScript.implicit_ids += 1
        self.script = script
        self.repeat = None
        self.timer = None # for repeat updates
        self.thread_lock = threading.Lock()
        self.thread_cancel = [False] # for cancelling thread execution

        dobj = DText('') # start out with empty text, fill in later with script result
        dobj.id = self.implicit_id
        self.append(dobj)

    def configure(self, key, value):
        if key == 'repeat':
            self.repeat = float(value)
        else:
            return DObject.configure(self, key, value)
        return True

    def stop(self):
        self.thread_lock.acquire()
        if self.timer is not None:
            self.timer.cancel()
        self.thread_cancel[0] = True
        self.thread_lock.release()

    def get_size(self):
        return self.elements[0].get_size()

    def draw(self, cr, x, y):
        return self.elements[0].draw(cr, x, y)

    def start_repeat(self):
        '''Set up timer to call update() after self.repeat seconds have elapsed'''
        if self.repeat is None or self.repeat < 0.001:
            return
        if self.timer is not None: # only one timer at a time
            return
        self.timer = threading.Timer(self.repeat, self.update, [])
        self.timer.start()

    def update(self):
        '''Executed for every repeat tick'''

        self.thread_lock.acquire()
        self.timer = None
        def do_update(container, script, myid, repeat, lock, cancel):
            lock.acquire()
            if cancel[0]:
                lock.release()
                return

            container.start_repeat()
            dobj = None
            try:
                strings = subprocess.check_output(self.script, shell=True)
                sp = SpecProcessor(strings)
                if sp.parse():
                    dobj = DBox()
                    sp.add_dobjects(dobj)

            except subprocess.CalledProcessError:
                dobj = DText('<failed: ' + self.script + '>', 'red')

            if dobj is not None:
                dobj.id = myid
                container.append(dobj)
                GUI.refresh_on_idle()
            lock.release()

        # start in separate thread so we don't have to wait for script to finish
        self.thread_cancel[0] = False
        thread = threading.Thread(target = do_update, args = [self, self.script, self.implicit_id, self.start_repeat, self.thread_lock, self.thread_cancel])
        thread.start()
        self.thread_lock.release()

    def configure_end(self):
        if self.id is None:
            self.id = self.implicit_id
        self.update()
        self.start_repeat()
        return True


class DLine(DContainer):
    '''Line of consecutive elements (+line)'''

    def __init__(self, elements=None):
        DContainer.__init__(self, elements)

    def get_size(self):
        result = [0, 0, 0]
        for e in self.elements:
            size = e.get_size()
            if result[0] > 0:
                result[0] += Config.column_separator_width
            result[0] += size[0]
            result[1] = max(result[1], size[1])
            result[2] = max(result[2], size[2])
        return tuple(result)

    def draw(self, cr, x, y):
        for e in self.elements:
            (width, e_baseline, _) = e.get_size()
            e.draw(cr, x, y)
            x += width + Config.column_separator_width

    def __str__(self):
        return 'line'+str(id(self))+'[' + ', '.join(str(s) for s in self.elements) + ']'


class DBox(DContainer):
    '''Multiple rows of elements'''
    def __init__(self, elements=None):
        DContainer.__init__(self, elements)

    def get_size(self):
        width = 0
        height = 0
        for l in self.elements:
            width = max(width, l.get_width())
            height += Config.line_separator_width + l.get_height()
        return (width, 0, height)

    def draw(self, cr, x, y):
        for l in self.elements:
            l.draw_to(cr, x, y)
            y += Config.line_separator_width + l.get_height()

    def __str__(self):
        return 'box[' + ', '.join(str(s) for s in self.elements) + ']'


################################################################################
# Our GTK widget, wrapped into lazily initialised graphics code
################################################################################

class GUI:
    def __init__(self):
        self.notifier = None	# global AwareWindow
        self.failed = False

        self._GLib = None
        self._Gtk = None
        self._Gdk = None
        self._Pango = None
        self._PangoCairo = None
        self._GtkLayerShell = None
        self.wayland = False

    @property
    def GLib(self):
        self.init_graphics()
        return self._GLib

    @property
    def GtkLayerShell(self):
        self.init_graphics()
        return self._GtkLayerShell

    @property
    def Gtk(self):
        self.init_graphics()
        return self._Gtk

    @property
    def Gdk(self):
        self.init_graphics()
        return self._Gdk

    @property
    def Pango(self):
        self.init_graphics()
        return self._Pango

    @property
    def PangoCairo(self):
        self.init_graphics()
        return self._PangoCairo

    def init_graphics(self):
        # We initialise libraries on demand, so that we can run aware without X11
        # to notify an X11 'aware' for the same user
        if self.failed:
            raise NoGUIException()

        if self._GLib is not None:
            return

        try:
            import gi
            gi.require_version('Gtk', '3.0')
            gi.require_version('PangoCairo', '1.0')
            from gi.repository import GLib, Gtk, Gdk, Pango, PangoCairo, GdkPixbuf
            if not Gtk.init_check()[0]:
                self.failed = True
                raise NoGUIException()

            self._GLib = GLib
            self._Gtk = Gtk
            self._Gdk = Gdk
            self._Pango = Pango
            self._PangoCairo = PangoCairo
            self._GdkPixbuf = GdkPixbuf

            # Wayland-only
            if sys.env['WAYLAND_DISPLAY'] is not None:
                try:
                    print('Trying for Wayland')
                    gi.require_version('GtkLayerShell', '0.1')
                    from gi.repository import GtkLayerShell
                    self._GtkLayerShell = GtkLayerShell
                    self.wayland = True
                except ValueError:
                    pass
        except RuntimeError:
            self.failed = True
            raise NoGUIException()

    def refresh_on_idle(self):
        self.init_graphics()
        self._GLib.idle_add(self.notifier.update)

    def make_window(self):
        self.init_graphics()
        gui = self

        class AwareWindow(self._Gtk.Window):
            __gtype_name__ = 'AwareWindow'
            '''Notification window'''

            def __init__(self, dobject):
                '''Initialise window with dobject to display'''
                #self._Gtk.Widget.__init__(self)
                gui._Gtk.Window.__init__(self, type=gui._Gtk.WindowType.TOPLEVEL)
                self.set_resizable(False)
                self.set_keep_above(True)
                self.set_accept_focus(False)
                # The following seems to look fine with text:
                self.pad_top = 0	# number of pixels to pad
                self.pad_bottom = 2
                self.pad_left = 5
                self.pad_right = 2

                self.window = None
                self.root_window = gui._Gdk.get_default_root_window()
                self.root_size = (self.root_window.get_width(), self.root_window.get_height())

                self.fg_color = parse_color(Config.bar_color)
                self.bg_color = parse_color(Config.default_bg_color)
                self.set_dobject(dobject, redraw=False)

                self.canvas = gui._Gtk.DrawingArea()
                self.canvas.connect("draw", self.draw_canvas)
                self.add(self.canvas)
                self.update(recompute_dimensions=False)

            def get_dobject(self):
                return self.dobject

            def update(self, recompute_dimensions=True, redraw=True):
                if recompute_dimensions:
                    self.update_dimensions()
                if redraw:
                    self.queue_draw()

            def set_dobject(self, dobject, redraw=True):
                self.dobject = dobject
                self.update(redraw=redraw)

            def get_pad_width(self):
                '''Total horizontal padding'''
                return self.pad_left + self.pad_right

            def get_pad_height(self):
                '''Total vertical padding'''
                return self.pad_top + self.pad_bottom

            def update_dimensions(self):
                '''Recompute size and trigger redraw'''
                if self.dobject is not None:
                    self.dobject.set_window(self)
                    self.width = self.dobject.get_width() + self.get_pad_width()
                    self.height = self.dobject.get_height() + self.get_pad_height()
                    self.resize(self.width, self.height)
                    if self.window is not None:
                        self.window.move_resize(self.root_size[0] - self.width, 0,
                                                self.width, self.height)
                    self.queue_draw()

            def do_realize(self):
                root = self.root_window
                allocation = self.get_allocation()
                attr = gui._Gdk.WindowAttr()
                attr.window_type = gui._Gdk.WindowType.TOPLEVEL
                attr.x = self.root_size[0] - self.width
                attr.y = 0
                attr.width = self.width
                attr.height = self.height
                attr.visual = self.get_visual()
                attr.event_mask = self.get_events() | gui._Gdk.EventMask.EXPOSURE_MASK
                WAT = gui._Gdk.WindowAttributesType
                mask = WAT.X | WAT.Y | WAT.VISUAL

                window = gui._Gdk.Window(root, attr, mask)
                window.set_override_redirect(True)
                window.set_keep_above(True)
                window.set_type_hint(gui._Gdk.WindowTypeHint.NOTIFICATION)

                self.window = window
                self.set_window(window)
                self.register_window(window)
                self.set_realized(True)

            def __do_unrealize(self):
                '''GTK widget window unrealisation'''
                # I doubt that this ever gets called for this widget
                self.window.set_user_data(None)

            def draw_canvas(self, area, cr):
                '''GTK notification that we should redraw'''

                rect = self.get_allocation()
                x = rect.x
                y = rect.y
                w = rect.width
                h = rect.height

                # clear background
                cr.save()
                cr.rectangle(0, 0, self.width, self.height)
                cr.set_operator(cairo.OPERATOR_SOURCE)
                cr.set_source_rgba(*self.bg_color)#.red, self.fg_color.green, self.fg_color.blue)
                cr.fill()
                cr.restore()

                # draw frame
                cr.save()
                cr.set_source_rgba(*self.fg_color)
                cr.rectangle(2, -2,
                             self.width, self.height)
                cr.set_line_width(1.0)
                cr.set_line_join(cairo.LINE_JOIN_ROUND)
                cr.stroke()
                cr.restore()

                # draw dobject
                self.dobject.draw_to(cr, self.pad_left, self.pad_top)


        class WaylandAwareWindow:
            '''Notification window for Wayland'''

            def __init__(self, dobject):
                '''Initialise window with dobject to display'''
                #self._Gtk.Widget.__init__(self)
                self.topwin = gui.Gtk.Window(type=gui._Gtk.WindowType.TOPLEVEL)

                self.topwin.set_resizable(False)
                self.topwin.set_keep_above(True)
                self.topwin.set_accept_focus(False)
                # The following seems to look fine with text:
                self.topwin.pad_top = 0	# number of pixels to pad
                self.topwin.pad_bottom = 2
                self.topwin.pad_left = 5
                self.topwin.pad_right = 2

                self.window = None
                self.root_window = gui._Gdk.get_default_root_window()
                self.root_size = (self.root_window.get_width(), self.root_window.get_height())

                self.topwin.fg_color = parse_color(Config.bar_color)
                self.topwin.bg_color = parse_color(Config.default_bg_color)
                self.set_dobject(dobject, redraw=False)

                self.topwin.canvas = gui._Gtk.DrawingArea()
                self.topwin.canvas.connect("draw", self.draw_canvas)
                self.topwin.add(self.topwin.canvas)
                self.update(recompute_dimensions=False)

                gui.GtkLayerShell.init_for_window(self.topwin)
                gui.GtkLayerShell.auto_exclusive_zone_enable(self.topwin)
                gui.GtkLayerShell.set_margin(self.topwin, gui.GtkLayerShell.Edge.TOP, 0)
                gui.GtkLayerShell.set_margin(self.topwin, gui.GtkLayerShell.Edge.RIGHT, 0)
                gui.GtkLayerShell.set_margin(self.topwin, gui.GtkLayerShell.Edge.LEFT, 0)
                gui.GtkLayerShell.set_margin(self.topwin, gui.GtkLayerShell.Edge.BOTTOM, 0)

                gui.GtkLayerShell.set_anchor(self.topwin, gui.GtkLayerShell.Edge.RIGHT, 1)
                gui.GtkLayerShell.set_anchor(self.topwin, gui.GtkLayerShell.Edge.TOP, 1)
                #self.topwin.resize(100,20)
                #self.do_realize()
                self.window = self.topwin

            def show_all(self):
                return self.topwin.show_all()

            def get_allocation(self):
                return self.topwin.get_allocation()

            def create_pango_layout(self, x):
                return self.topwin.create_pango_layout(x)

            def get_dobject(self):
                return self.dobject

            def update(self, recompute_dimensions=True, redraw=True):
                if recompute_dimensions or True:
                    self.update_dimensions()
                if redraw or True:
                    self.topwin.queue_draw()

            def set_dobject(self, dobject, redraw=True):
                self.dobject = dobject
                self.update(redraw=redraw)

            def get_pad_width(self):
                '''Total horizontal padding'''
                return self.topwin.pad_left + self.topwin.pad_right

            def get_pad_height(self):
                '''Total vertical padding'''
                return self.topwin.pad_top + self.topwin.pad_bottom

            def resize(self, w, h):
                self.topwin.set_size_request(w, h)
                self.topwin.resize(1, 1)

            def update_dimensions(self):
                '''Recompute size and trigger redraw'''
                if self.dobject is not None:
                    self.dobject.set_window(self.topwin)
                    print('A')
                    self.topwin.width = self.dobject.get_width() + self.get_pad_width()
                    print('C')
                    self.topwin.height = self.dobject.get_height() + self.get_pad_height()
                    print('B')
                    self.resize(self.topwin.width, self.topwin.height)
                    print(self.topwin.width, self.topwin.height)
                    self.topwin.queue_draw()
                    #gui.GtkLayerShell.init_for_window(self.topwin)
                    #self.topwin.show_all()
                    print('D')

            def __do_unrealize(self):
                '''GTK widget window unrealisation'''
                # I doubt that this ever gets called for this widget
                self.window.set_user_data(None)

            def draw_canvas(self, area, cr):
                '''GTK notification that we should redraw'''

                rect = self.get_allocation()
                x = rect.x
                y = rect.y
                w = rect.width
                h = 100#rect.height

                # clear background
                cr.save()
                cr.rectangle(0, 0, self.topwin.width, self.topwin.height)
                cr.set_operator(cairo.OPERATOR_SOURCE)
                cr.set_source_rgba(*self.topwin.bg_color)#.red, self.fg_color.green, self.fg_color.blue)
                cr.fill()
                cr.restore()

                # draw frame
                cr.save()
                cr.set_source_rgba(*self.topwin.fg_color)
                cr.rectangle(2, -2,
                             self.topwin.width, self.topwin.height)
                cr.set_line_width(1.0)
                cr.set_line_join(cairo.LINE_JOIN_ROUND)
                cr.stroke()
                cr.restore()

                # draw dobject
                self.dobject.draw_to(cr, self.topwin.pad_left, self.topwin.pad_top)

        if gui.wayland:
            self.notifier = WaylandAwareWindow(DBox())
        else:
            self.notifier = AwareWindow(DBox())
        return self.notifier

    def update_notifier(self, message):
        '''Parse message and append it to the notifier if set'''
        try:
            sp = SpecProcessor(message)
            if sp.parse():
                def update():
                    sp.add_dobjects(self.notifier.get_dobject())
                    self.notifier.update()
                self._GLib.idle_add(update)
        except Exception as e:
            raise e
            print(str(e), file=sys.stderr)
            log(traceback.format_exc())
            return False
        return True

GUI = GUI()

################################################################################
# Input spec parsing and processing
################################################################################

class ParseError(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)


class TokenStream(object):
    '''Represents a token stream and an iteration over it'''

    def __init__(self, tokenlist):
        self.tokens = tokenlist
        self.pos = 0
        self.err = log

    def set_err(self, fn):
        self.err = fn

    def get_tokens(self):
        return self.tokens

    def has_next(self):
        return self.pos < len(self.tokens)

    def peek(self):
        if self.has_next():
            return self.tokens[self.pos]

    def next(self):
        if self.has_next():
            r = self.tokens[self.pos]
            self.pos += 1
            return r
        else:
            self.err('incomplete specification')

    def concat_until(self, acceptset, failset):
        result = ''
        while True:
            s = self.next()
            if s in acceptset:
                return (result, s)
            elif s in failset:
                self.err('Unexpected "%s"' % s)
            else:
                if result == '':
                    result = s
                else:
                    result = result + ' ' + s


class SpecProcessor(object):
    '''Parses specification input and produces an output DObject'''

    def __init__(self, string):
        if type(string) == bytes:
            string = string.decode('utf-8')
        self.lines = [l for l in string.split('\n') if len(l) > 0]

    def tokenize(self, s):
        '''Tokenisation part of the SpecProcessor'''
        # first, remove tail end, i.e., the body
        index = 0
        parentheses = 0
        tail = ''
        while index < len(s):
            if s[index] == '(':
                parentheses += 1
            elif s[index] == ')':
                parentheses -= 1
            elif s[index] == '=' and parentheses == 0:
                tail = s[(index + 1):]
                s = s[:(index + 1)]
                break
            index += 1
        if index == len(s):
            s += '=' # add implicit termination if needed

        singles = '=,()'
        index = 0
        results = []

        def err(l):
            log('Unexpected character while processing line:')
            log('%s' % l)
            log((' ' * index) + '^')

        def islegal(p):
            return p.isalnum() or p in '#_+-!@%*'

        while index < len(s):
            c = s[index]

            if c in singles:
                results.append(c)
            elif c.isspace():
                pass
            elif islegal(c):
                start = index
                while index < len(s) and islegal(s[index]):
                    index += 1
                results.append(s[start:index])
                continue
            else:
                err(s)
                return None
            index += 1

        return (TokenStream(results), tail)

    def dobject_for(self, name, body):
        '''Map display type to display object'''
        if name == 'text':
            return DText(body)
        elif name == 'img':
            return DImage(body)
        elif name == 'line':
            return DLine()
        elif name == 'script':
            return DScript(body)
        return None

    def add_dobjects(self, dbox):
        '''Adds a finished object to the computed dbox'''
        for l in self.line_results:
            dbox.append(l)

    def parse(self):
        '''Returns True if parsing succeeded; prints error messages as appropriate'''
        results = []
        self.dline = None

        try:
            def result_append(dobj):
                if type(dobj) is DLine:
                    dline_finish()
                    self.dline = dobj
                else:
                    if self.dline is None:
                        results.append(dobj)
                    else:
                        self.dline.append(dobj)

            def dline_finish():
                if self.dline is not None:
                    results.append(self.dline)
                self.dline = None

            for l in self.lines:
                def err(s):
                    log('Error in line "%s":' % l)
                    log('\t', s)
                    raise ParseError(None)

                if l.startswith(CONTROL_CHAR):
                    # command
                    tokenset = self.tokenize(l[1:])
                    if tokenset is None:
                        result_append(DText('<ERROR>', color='red'))
                        continue
                    (tokens, body) = tokenset

                    tokens.set_err(err)
                    dname = tokens.next()
                    try:
                        dobj = self.dobject_for(dname, body)
                    except Exception as e:
                        log(e.message)
                        log(traceback.format_exc())
                        dobj = DText('<ERROR>', color='red')

                    if dname == 'endline':
                        dline_finish()
                        continue

                    if dobj == None:
                        err('Unknown or unsupported display type "%s"' % dname)

                    if tokens.peek() == '=':
                        result_append(dobj)
                        continue # no parameters
                    oparen = tokens.next()
                    if oparen != '(':
                        err('Expected "(" or ":" after %s' % dname)

                    term = ''
                    while term != ')':
                        (key, _) = tokens.concat_until('=', ',()')
                        (value, term) = tokens.concat_until('),', '=()')
                        if not dobj.configure(key, value):
                            err('invalid specification: "%s:%s"' % (key, value))

                    if not dobj.configure_end():
                        err('incompatible specification')

                    result_append(dobj)
                else:
                    result_append(DText(l.strip()))

            dline_finish()
        except ParseError as e:
            return False

        self.line_results = results
        return True


################################################################################
# IPC communication
################################################################################

# IPC messages
MESSAGE_SHUTDOWN = 'SHUTDOWN'
MESSAGE_FORCE_SHUTDOWN = 'FORCE-SHUTDOWN'
MESSAGE_UPDATE = 'UPDATE'
MESSAGE_END = 'END'

MESSAGES_DEBUG = False

class ListenerAlreadyExistsException(Exception):
    def __init__(self):
        pass

class NoGUIException(Exception):
    def __init__(self):
        pass


class AwarePipe(object):
    '''Named pipe support (and pid-based validation) for communication'''

    def __init__(self, filename = None, pid_filename = None):
        if filename is None:
            filename = Config.pipe_file_name
        if pid_filename is None:
            pid_filename = Config.pid_file_name
        self.filename = filename
        self.pid_filename = pid_filename
        self.allocation_tries = ALLOCATION_TRIES

    def pipe_exists(self):
        '''Does the pipe exist?'''
        if not os.path.exists(self.filename):
            if MESSAGES_DEBUG:
                print('[pipe] no pipe file found: %d' % (os.path.exists(self.filename)))
            return False
        return True

    def lockfile_exists(self):
        '''Does the lock file exist, and is the PID in the lock file up to date?  Does it point to a python process?'''
        if not os.path.exists(self.pid_filename):
            if MESSAGES_DEBUG:
                print('[pipe] no lock file found: %d' % (os.path.exists(self.pid_filename)))
            return False
        claimed_pid = 0
        with read_exclusive(self.pid_filename) as f:
            try:
                claimed_pid = int(f.read())
            except ValueError:
                if MESSAGES_DEBUG:
                    print('[pipe] exists, but pid is ill-formed (shouldnot happen!)')
                return False
            if MESSAGES_DEBUG:
                print('[pipe] exists, supposedly for pid %d' % claimed_pid)
        try:
            proc_name = subprocess.check_output(['/bin/ps', '-p', '%d' % claimed_pid, '-o', 'comm=']).strip()
            proc_name = proc_name.decode('ascii')
            if MESSAGES_DEBUG:
                print('[pipe] procname = "%s"' % proc_name)
        except subprocess.CalledProcessError:
            if MESSAGES_DEBUG:
                print('[pipe] /bin/ps failed for pid %d: no such process?' % claimed_pid)
            return False
        if proc_name != 'python' and proc_name != 'python3':
            if MESSAGES_DEBUG:
                print('[pipe] pipe is stale')
            return False
        if MESSAGES_DEBUG:
            print('[pipe] pipe exists and seems ready')
        return True

    def exists(self):
        '''Does the pipe exist?  Is the PID up to date?  Does it point to a python process?  Cleans up if not.'''
        if self.lockfile_exists():
            for n in range(1, 11):
                pipe_ok = self.pipe_exists()
                if pipe_ok:
                    return True
                # Inconsistent state: most likely someone is in the middle of setting things up
                time.sleep(0.0001 * n)

            # Nobody set up the pipe;
            if MESSAGES_DEBUG:
                print('[pipe] assuming misclassified lock file pid; cleaning up')
            self.cleanup()

        if self.pipe_exists():
            if self.lockfile_exists():
                return True

            if MESSAGES_DEBUG:
                print('[pipe] pipe without lock file: cleaning up')
            self.cleanup()


        return False

    def listener(self):
        '''Creates an UpdateListener, or raises ListenerAlreadyExistsException if we couldn't get an exclusive lock.
        Stores pid for later validity checking, on success.'''
        if self.allocation_tries == 0:
            sys.stderr.write("Failed to acquire lock on %s\n" % (self.pid_filename))
            sys.exit(1)

        self.allocation_tries -= 1

        if MESSAGES_DEBUG:
            print('[pipe] trying to grab lockfile "%s"' % self.pid_filename)
        pidfile = create_exclusive(self.pid_filename)
        if pidfile is None:
            if MESSAGES_DEBUG:
                print('[pipe] no exception, but no success either')
            raise ListenerAlreadyExistsException()

        pidfile.write('%s' % os.getpid())
        pidfile.close()

        os.mkfifo(self.filename) # BUG 1, 3
        if MESSAGES_DEBUG:
            print('[pipe] starting update listener')
        return UpdateListener(self.filename)

    def open_writer(self):
        '''Opens pipe for writing.'''
        fd = open(self.filename, 'w')
        fcntl.flock(fd, fcntl.LOCK_EX)
        return fd

    def cleanup(self):
        '''Best-effort pipe and pid file cleanup.'''
        try:
            os.remove(self.pid_filename)
        except OSError:
            pass
        try:
            os.remove(self.filename)
        except OSError:
            pass


class UpdateListener(threading.Thread):
    '''Background thread for listening and processing commands via named pipe'''

    def __init__(self, fifo_name):
        threading.Thread.__init__(self)
        self.fifo_name = fifo_name
        self.most_recent_update = time.time()
        self.lines = []
        if MESSAGES_DEBUG:
            print('[UL] listener started')

    def run(self):
        '''Continuously polls for input/updates via named pipe.'''
        buffer = ''
        try:
            while True:
                f = open(self.fifo_name, 'r')
                while not f.closed:
                    update = f.read()
                    buffer += update
                    new_lines = buffer.split('\n')
                    if len(new_lines) > 0:
                        buffer = new_lines[-1]
                        self.lines += new_lines[:len(new_lines) - 1]
                        if MESSAGES_DEBUG:
                            print('[UL] read (aggregate): "%s"' % self.lines)
                        self.process_command()
                    if update == '': # eof
                        f.close()
        finally:
            AwarePipe().cleanup()


    def process_command(self):
        '''Processes fully-read input (in self.lines).  Returns True iff a pipe reset is needed.'''
        ret = False
        while len(self.lines) > 0:
            if self.lines[0] == '':
                self.lines = self.lines[1:]
                continue
            if self.lines[0] == MESSAGE_SHUTDOWN or self.lines[0] == MESSAGE_FORCE_SHUTDOWN:
                if ((time.time() > self.most_recent_update + Config.update_safety_delay)
                    or self.lines[0] == MESSAGE_FORCE_SHUTDOWN):

                    # This solution is brutal but effective
                    try:
                        # Shouldn't need the extra 'try' block in practi
                        AwarePipe().cleanup()
                    except:
                        pass
                    os.kill(os.getpid(), signal.SIGKILL) # this seems to be the only thing that works...
                # otherwise ignore the shutdown request to avoid having the user miss something
                self.lines = self.lines[1:]
            elif self.lines[0] == MESSAGE_UPDATE:
                self.most_recent_update = time.time()
                i = 0
                end = -1
                while i + 1 < len(self.lines):
                    i += 1
                    if self.lines[i] == MESSAGE_END:
                        end = i
                        ret = True
                        break;
                if end == -1:
                    # message not finished
                    return False
                updates = self.lines[1:end]
                self.lines = self.lines[(i+1):]
                update_spec = '\n'.join(u[1:] for u in updates) + '\n'
                GUI.update_notifier(update_spec)
            else:
                log('listener: Garbage command "%s"' % self.lines[0])
                self.lines = self.lines[1:]
        return ret


################################################################################
# Main class
################################################################################

class Main(object):
    '''Main class'''

    def __init__(self):
        Config() # init config file
        parser = argparse.ArgumentParser(description='Pop up a custom informative message without grabbing focus.',
                                         # epilog doesn't make it easy to use formatting, and I'm too lazy to write a
                                         # custom formatter class.
                                         epilog='''
                                         Messages can be plain-text or use special formatting.  To use special
                                         formatting, start a line with `+', followed by formatting directions
                                         (e.g., +img:path/to/image.png).  See the man page for details.
                                         ''')

        parser.add_argument('text', metavar='T', type=str, nargs='*',
                            help='Messages to display, one per line (see below), or - to read from stdin')
        parser.add_argument('--foreground', dest='main', action='store_const',
                            const=self.main, default=self.main_daemon,
                            help='Run in foreground mode, forego daemonisation (for debugging)')
        parser.add_argument('-s', '--stop', dest='action', action='store_const',
                            const=self.stop, default=self.display,
                            help='Stop displaying')
        parser.add_argument('--force-stop', dest='action', action='store_const',
                            const=self.force_stop, default=self.display,
                            help='Stop displaying, overriding safety delay')
        parser.add_argument('-v', '--version', dest='action', action='store_const',
                            const=self.version, default=self.display,
                            help='Display version')
        parser.add_argument('-m', '--message', dest='action', action='store_const',
                            const=self.display, default=self.display,
                            help='Display message (default)')
        self.parser = parser
        self.pipe = AwarePipe()

    def run(self):
        '''Processes command line arguments and actions.'''
        self.args = self.parser.parse_args()
        self.args.action()

    def version(self):
        '''Toplevel command: Prints version and copyright information.'''
        print('aware, version', VERSION)
        print('Copyright (C) 2015-2021 Christoph Reichenbach <creichen%sgmail.com>' % '@')
        print('This program is provided WITHOUT WARRANTY, either expressed or implied, under the terms of the GNU GPL v2.')

    def get_stdin(self, prefix=''):
        '''read stdin, prefixing each line as specified'''
        buffer = ''
        for line in fileinput.input():
            buffer += prefix + line + '\n'
        return buffer

    def message(self, prefix=''):
        '''Get the display information to show, reading from stdin iff requested'''
        text_fragments = self.args.text
        if text_fragments == ['-']:
            return self.get_stdin(prefix)
        else:
            newline = True
            body = '\n'.join(prefix + s for s in text_fragments)
            return body

    def display(self):
        '''Toplevel command: print out messages'''
        retry = True
        try_gui = True

        while retry:
            retry = False
            try:
                if self.pipe.exists():
                    buf = self.message('!') # prepend '!' to each line as part of the transfer protocol to avoid confusion with messages
                    with self.pipe.open_writer() as f:
                        f.write('\n' + MESSAGE_UPDATE + '\n')
                        f.write(buf)
                        f.write('\n' + MESSAGE_END + '\n')
                else:
                    retval = 1
                    if try_gui:
                        retval = self.args.main(self.message())
                    else:
                        print('No GUI available, aborting.')
                    self.pipe.cleanup()
                    sys.exit(retval)
            except ListenerAlreadyExistsException:
                retry = True
            except NoGUIException:
                retry = True
                try_gui = False

    def stop(self):
        '''Toplevel command: stop showing messages'''
        if not self.pipe.exists():
            return
        else:
            with self.pipe.open_writer() as f:
                f.write(MESSAGE_SHUTDOWN + '\n')

    def force_stop(self):
        '''Toplevel command: stop showing messages forcefully'''
        if not self.pipe.exists():
            return
        else:
            with self.pipe.open_writer() as f:
                f.write(MESSAGE_FORCE_SHUTDOWN + '\n')

    def main_daemon(self, message):
        '''Run main() in background'''
        try:
            pid = os.fork()
            if pid > 0:
                sys.exit(0)
        except OSError as e:
            sys.stderr.write("Failed to start daemon: %d (%s)\n" % (e.errno, e.strerror))
            return 1
        log_output = None
        self.main(message)

    def main(self, message):
        '''Show window and wait for further updates via pipe'''

        # try to fail early
        GUI.init_graphics()

        # start pipe communication
        dl = self.pipe.listener()
        dl.start()

        win = GUI.make_window()

        if not GUI.update_notifier(message):
            # failed to start up properly
            dl.stop()
            self.pipe.cleanup()
            os.kill(os.getpid(), signal.SIGKILL) # this seems to be the only thing that works...

        win.show_all()
        GUI.Gtk.main()


if __name__ == '__main__':
    m = Main()
    m.run()
    sys.exit(0)

